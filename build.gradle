import java.text.SimpleDateFormat

/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

plugins {
    id 'net.nemerosa.versioning'        version '2.7.1'
    id 'com.jfrog.bintray'              version '1.8.4'  apply false
    id 'com.gradle.plugin-publish'      version '0.10.0' apply false
    id 'com.github.ben-manes.versions'  version '0.20.0' apply false
    id 'com.github.hierynomus.license'  version '0.14.0' apply false
}

apply from: 'gradle/credentials.gradle'

Date buildTimeAndDate = new Date()
ext {
    buildBy = System.properties['user.name']
    buildDate = new SimpleDateFormat('yyyy-MM-dd').format(buildTimeAndDate)
    buildTime = new SimpleDateFormat('HH:mm:ss.SSSZ').format(buildTimeAndDate)
    buildRevision = versioning.info.commit
    buildJdk = "${System.properties['java.version']} (${System.properties['java.vendor']} ${System.properties['java.vm.version']})".toString()
    buildCreatedBy = "Gradle ${gradle.gradleVersion}"
}

allprojects {
    apply plugin: 'base'
    apply plugin: 'idea'
    apply plugin: 'com.github.ben-manes.versions'
    apply from: rootProject.file('gradle/license.gradle')

    repositories {
        jcenter()
        maven { url 'http://dl.bintray.com/pledbrook/plugins' }
    }

    dependencyUpdates.resolutionStrategy = {
        componentSelection { rules ->
            rules.all { selection ->
                boolean rejected = ['alpha', 'beta', 'rc', 'cr'].any { qualifier ->
                    selection.candidate.version ==~ /(?i).*[.-]${qualifier}[.\d-]*/
                }
                if (rejected) {
                    selection.reject('Release candidate')
                }
            }
        }
    }
}

subprojects {
    apply plugin: 'groovy'
    apply plugin: 'java-gradle-plugin'

    dependencies {
        compile gradleApi()
    }

    compileGroovy {
        sourceCompatibility = project.sourceCompatibility
        targetCompatibility = project.targetCompatibility
    }

    groovydoc {
        use             = true
        source          = project.sourceSets.main.allSource
        classpath       = javadoc.classpath
        ext.windowtitle = "$project.name $project.version API"
        ext.doctitle    = "$project.name $project.version API"
        header          = "$project.name $project.version API"
        footer          = "Copyright &copy; ${copyrightYear} the original author or authors. All rights reserved."
        includePrivate  = false
        link 'https://docs.gradle.org/4.0/javadoc/', 'org.gradle.'
        link 'http://docs.oracle.com/javase/8/docs/api/', 'java.', 'org.xml.', 'javax.', 'org.w3c.'
    }

    task sourcesJar(type: Jar) {
        group 'Build'
        description 'An archive of the source code'
        classifier 'sources'
        from sourceSets.main.allSource
    }

    task javadocJar(type: Jar, dependsOn: groovydoc) {
        group 'Build'
        description 'An archive of the javadoc'
        classifier 'javadoc'
        dependsOn javadoc
        from groovydoc.destinationDir
    }

    jar.finalizedBy sourcesJar
    jar.finalizedBy javadocJar

    artifacts {
        sourcesJar
        javadocJar
    }

    gradlePlugin {
        plugins {
            "${project.name.replaceAll('-','_')}Plugin" {
                id = project.pluginId
                implementationClass = project.pluginImplementationClass
            }
        }
    }

    project.tasks.withType(Test) {
        beforeTest { descriptor ->
            logger.lifecycle("Running test: " + descriptor)
        }

        onOutput { descriptor, event ->
            logger.lifecycle("Test: " + descriptor + " produced standard out/err: " + event.message )
        }

        testLogging {
            showStandardStreams = true
            afterSuite { desc, result ->
                if (!desc.parent) {
                    println "Test results ${project.name}: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} passed, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
                }
            }
        }
    }

    apply from: rootProject.file('gradle/publishing.gradle')

    task publishRelease(dependsOn: [bintrayUpload, publishPlugins]) {}
}